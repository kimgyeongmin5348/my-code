#define _CRT_SECURE_NO_WARNINGS //--- 프로그램 맨 앞에 선언할 것
#include <stdlib.h>
#include <stdio.h>
#include <iostream>
#include <fstream>
#include <gl/glew.h>
#include <gl/freeglut.h>
#include <gl/freeglut_ext.h>
#include <glm/glm.hpp>
#include <glm/ext.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <random>

#define width 1000
#define height 800
#define h_vertex 0.5f


using namespace std;

float hexa[] =
{   //육면체
	//윗면
	-h_vertex, h_vertex, h_vertex,
	h_vertex, h_vertex, h_vertex,
	-h_vertex, h_vertex, -h_vertex,

	h_vertex, h_vertex, h_vertex,
	h_vertex, h_vertex, -h_vertex,
	-h_vertex, h_vertex, -h_vertex,
	//정면
	-h_vertex, -h_vertex, h_vertex,
	h_vertex, -h_vertex, h_vertex,
	-h_vertex, h_vertex, h_vertex,

	h_vertex, -h_vertex, h_vertex,
	h_vertex, h_vertex, h_vertex,
	-h_vertex, h_vertex, h_vertex,

	//아랫면
	-h_vertex, -h_vertex, h_vertex,
	-h_vertex, -h_vertex, -h_vertex,
	h_vertex, -h_vertex, -h_vertex,

	-h_vertex, -h_vertex, h_vertex,
	h_vertex, -h_vertex, -h_vertex,
	h_vertex, -h_vertex, h_vertex,

	//뒷면
	h_vertex, -h_vertex, -h_vertex,
	-h_vertex, -h_vertex, -h_vertex,
	h_vertex, h_vertex, -h_vertex,

	-h_vertex, -h_vertex, -h_vertex,
	-h_vertex, h_vertex, -h_vertex,
	h_vertex, h_vertex, -h_vertex,


	//좌측면
	-h_vertex, -h_vertex, -h_vertex,
	-h_vertex, h_vertex, h_vertex,
	-h_vertex, h_vertex, -h_vertex,

	-h_vertex, -h_vertex, -h_vertex,
	-h_vertex, -h_vertex, h_vertex,
	-h_vertex, h_vertex, h_vertex,

	//우측면
   h_vertex, -h_vertex, h_vertex,
   h_vertex, -h_vertex, -h_vertex,
   h_vertex, h_vertex, h_vertex,

   h_vertex, -h_vertex, -h_vertex,
   h_vertex, h_vertex, -h_vertex,
   h_vertex, h_vertex, h_vertex
};

float bottom[] =
{
	1, 0, -1,
	-1, 0, 1,
	1, 0, 1,
	1, 0, -1,
	-1, 0, -1,
	-1, 0, 1
};

GLvoid drawScene();
GLvoid Reshape(int, int);
GLvoid KeyBoard(unsigned char, int, int);
GLvoid Setting();

GLUquadricObj* qobj;
GLuint s_program;
GLuint VAO[3], VBO[6];
GLuint shaderID;
GLuint vertexShader;
GLuint fragmentShader;
GLenum obj_type{ GL_FILL };
GLint g_window_w, g_window_h;

typedef struct object {
	float x_rotate{}, y_rotate{}, z_rotate{};
	float x_rotate_aoc{}, y_rotate_aoc{}, z_rotate_aoc{};
	float x_trans{}, y_trans{}, z_trans{}, x_trans1{};
	float x_trans_aoc{}, y_trans_aoc{}, z_trans_aoc{};
	float x_scale{}, y_scale{}, z_scale{};
}O;

typedef struct function {
	bool cull{ false };
	bool y_rotate{ false };
	bool x_is_trans{ false }, y_is_trans{ false }, z_is_trans{ false };
	bool x_is_reverse_trans{ false }, y_is_reverse_trans{ false }, z_is_reverse_trans{ false };
	bool x_is_rotate{ false }, y_is_rotate{ false }, z_is_rotate{ false };
	bool x_is_reverse_rotate{ false }, y_is_reverse_rotate{ false }, z_is_reverse_rotate{ false };
	bool start_timer{ true };
	bool door_open{ false }, door_close{ false };
	bool collision{ false };
}F;

O s, temp, camera, robot_arm, robot_leg, robot, block;
O l;
F h_f, temp_f;
int count{};
bool change_type{ false };
bool pers{ true };


GLchar* filetobuf(const GLchar* file)
{
	FILE* fptr;
	long length;
	GLchar* buf;

	fopen_s(&fptr, file, "rb");
	if (!fptr)
		return NULL;

	fseek(fptr, 0, SEEK_END);
	length = ftell(fptr);
	buf = (GLchar*)malloc(length + 1);
	fseek(fptr, 0, SEEK_SET);
	fread(buf, length, 1, fptr);
	fclose(fptr);
	buf[length] = 0;

	return buf;
}

void make_vertexShaders()
{
	GLchar* vertexSource;
	vertexSource = filetobuf("vertex.glsl");
	vertexShader = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(vertexShader, 1, &vertexSource, NULL);
	glCompileShader(vertexShader);
}

void make_fragmentShader()
{
	GLchar* fragmentSource;
	fragmentSource = filetobuf("fragment.glsl");
	fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(fragmentShader, 1, &fragmentSource, NULL);
	glCompileShader(fragmentShader);

}

void InitShader()
{
	make_vertexShaders();
	make_fragmentShader();

	s_program = glCreateProgram();

	glAttachShader(s_program, vertexShader);
	glAttachShader(s_program, fragmentShader);
	glLinkProgram(s_program);

	GLint result;
	GLchar errorLog[512];
	glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &result);
	if (!result)
	{
		glGetShaderInfoLog(fragmentShader, 512, NULL, errorLog);
		cerr << "ERROR :  fragment Shader Fail Compile \n" << errorLog << endl;
		exit(-1);
	}

	else
		cout << "good";
	glDeleteShader(vertexShader);
	glDeleteShader(fragmentShader);
	glUseProgram(s_program);
}

GLvoid InitBuffer()
{
	glGenVertexArrays(3, VAO);

	//->line
	glBindVertexArray(VAO[0]);
	glGenBuffers(2, &VBO[0]);
	glBindBuffer(GL_ARRAY_BUFFER, VBO[0]);
	glBufferData(GL_ARRAY_BUFFER, sizeof(hexa), hexa, GL_STATIC_DRAW);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);

	glBindVertexArray(VAO[1]);
	glGenBuffers(2, &VBO[2]);
	glBindBuffer(GL_ARRAY_BUFFER, VBO[2]);
	glBufferData(GL_ARRAY_BUFFER, sizeof(bottom), bottom, GL_STATIC_DRAW);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray(0);
}

void drawScene()
{
	glClearColor(0.2f, 0.2f, 0.2f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //깊이 체크 (컬링)
	glUseProgram(s_program);

	glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, -0.3f);			//위치
	glm::vec3 cameraDirection = glm::vec3(0.0f, 0.0f, 0.0f);	//바라보는 방향
	glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);			//카메라 상향
	glm::mat4 view = glm::mat4(1.0f);
	view = glm::lookAt(cameraPos, cameraDirection, cameraUp);

	view = glm::rotate(view, glm::radians(-30.f), glm::vec3(1.0f, 0.0f, 0.0f));

	view = glm::rotate(view, glm::radians(camera.y_rotate_aoc), glm::vec3(0.0f, 1.0f, 0.0f));

	view = glm::translate(view, glm::vec3(camera.x_trans, camera.y_trans, camera.z_trans));


	unsigned int viewLocation = glGetUniformLocation(s_program, "view");
	glUniformMatrix4fv(viewLocation, 1, GL_FALSE, &view[0][0]);

	if (!pers) {
		glm::mat4 projection = glm::mat4(1.0f);
		projection = glm::ortho(-2.0f, 2.0f, -2.0f, 2.0f, -100.0f, 100.0f);
		unsigned int projectionLocation = glGetUniformLocation(s_program, "projection");
		glUniformMatrix4fv(projectionLocation, 1, GL_FALSE, &projection[0][0]);
	}
	else {
		glm::mat4 projection = glm::mat4(1.0f);
		projection = glm::perspective(glm::radians(45.0f), 1.0f, 0.1f, 50.0f);
		projection = glm::translate(projection, glm::vec3(0.0, 0.0, -5.0));
		unsigned int projectionLocation = glGetUniformLocation(s_program, "projection");
		glUniformMatrix4fv(projectionLocation, 1, GL_FALSE, &projection[0][0]);
	}
	// 무대 만들기
	// 밑면
	glm::mat4 Box = glm::mat4(1.0f);
	Box = glm::translate(Box, glm::vec3(0.f, -1.5f, 1.5f));
	Box = glm::scale(Box, glm::vec3(1.5f, 0.0f, 1.5f));
	unsigned int StransformLocation = glGetUniformLocation(s_program, "transform");
	glUniformMatrix4fv(StransformLocation, 1, GL_FALSE, glm::value_ptr(Box));
	qobj = gluNewQuadric();
	gluQuadricDrawStyle(qobj, obj_type);
	int objColorLocation = glGetUniformLocation(s_program, "objectColor");
	unsigned isCheck = glGetUniformLocation(s_program, "isCheck");
	glUniform1f(isCheck, false);
	glUniform4f(objColorLocation, 0.0f, 1.0f, 1.0f, 1.0);
	glBindVertexArray(VAO[1]);
	glDrawArrays(GL_TRIANGLES, 0, 36);
	// 오른쪽 면
	glm::mat4 Box1 = glm::mat4(1.0f);
	Box1 = glm::translate(Box1, glm::vec3(-1.5f, 0.0f, 1.5f));
	Box1 = glm::rotate(Box1, glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f));
	Box1 = glm::scale(Box1, glm::vec3(1.5f, 0.0f, 1.5f));
	StransformLocation = glGetUniformLocation(s_program, "transform");
	glUniformMatrix4fv(StransformLocation, 1, GL_FALSE, glm::value_ptr(Box1));
	qobj = gluNewQuadric();
	gluQuadricDrawStyle(qobj, obj_type);
	objColorLocation = glGetUniformLocation(s_program, "objectColor");
	isCheck = glGetUniformLocation(s_program, "isCheck");
	glUniform1f(isCheck, false);
	glUniform4f(objColorLocation, 1.0f, 0.0f, 1.0f, 1.0);
	glBindVertexArray(VAO[1]);
	glDrawArrays(GL_TRIANGLES, 0, 36);
	// 뒷면
	glm::mat4 Box2 = glm::mat4(1.0f);
	Box2 = glm::translate(Box2, glm::vec3(0.f, 0.0f, 3.0f));
	Box2 = glm::rotate(Box2, glm::radians(90.0f), glm::vec3(1.0f, 0.0f, 0.0f));
	Box2 = glm::scale(Box2, glm::vec3(1.5f, 0.0f, 1.5f));
	StransformLocation = glGetUniformLocation(s_program, "transform");
	glUniformMatrix4fv(StransformLocation, 1, GL_FALSE, glm::value_ptr(Box2));
	qobj = gluNewQuadric();
	gluQuadricDrawStyle(qobj, obj_type);
	objColorLocation = glGetUniformLocation(s_program, "objectColor");
	isCheck = glGetUniformLocation(s_program, "isCheck");
	glUniform1f(isCheck, false);
	glUniform4f(objColorLocation, 1.0f, 0.0f, 0.0f, 1.0);
	glBindVertexArray(VAO[1]);
	glDrawArrays(GL_TRIANGLES, 0, 36);
	// 왼쪽 면
	glm::mat4 Box3 = glm::mat4(1.0f);
	Box3 = glm::translate(Box3, glm::vec3(1.5f, 0.0f, 1.5f));
	Box3 = glm::rotate(Box3, glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f));
	Box3 = glm::scale(Box3, glm::vec3(1.5f, 0.0f, 1.5f));
	StransformLocation = glGetUniformLocation(s_program, "transform");
	glUniformMatrix4fv(StransformLocation, 1, GL_FALSE, glm::value_ptr(Box3));
	qobj = gluNewQuadric();
	gluQuadricDrawStyle(qobj, obj_type);
	objColorLocation = glGetUniformLocation(s_program, "objectColor");
	isCheck = glGetUniformLocation(s_program, "isCheck");
	glUniform1f(isCheck, false);
	glUniform4f(objColorLocation, 0.0f, 1.0f, 0.0f, 1.0);
	glBindVertexArray(VAO[1]);
	glDrawArrays(GL_TRIANGLES, 0, 36);
	// 윗면
	glm::mat4 Box4 = glm::mat4(1.0f);
	Box4 = glm::translate(Box4, glm::vec3(0.f, 1.5f, 1.5f));
	Box4 = glm::scale(Box4, glm::vec3(1.5f, 0.0f, 1.5f));
	StransformLocation = glGetUniformLocation(s_program, "transform");
	glUniformMatrix4fv(StransformLocation, 1, GL_FALSE, glm::value_ptr(Box4));
	qobj = gluNewQuadric();
	gluQuadricDrawStyle(qobj, obj_type);
	objColorLocation = glGetUniformLocation(s_program, "objectColor");
	isCheck = glGetUniformLocation(s_program, "isCheck");
	glUniform1f(isCheck, false);
	glUniform4f(objColorLocation, 0.0f, 0.0f, 1.0f, 1.0);
	glBindVertexArray(VAO[1]);
	glDrawArrays(GL_TRIANGLES, 0, 36);
	// 무대 문(오른쪽)
	glm::mat4 Door = glm::mat4(1.0f);
	Door = glm::translate(Door, glm::vec3(-0.75f, 0.0f, 0.0f));
	Door = glm::rotate(Door, glm::radians(90.0f), glm::vec3(1.0f, 0.0f, 0.0f));
	Door = glm::translate(Door, glm::vec3(s.x_trans, 0.f, 0.f));
	Door = glm::scale(Door, glm::vec3(0.75f, 0.0f, 1.5f));
	StransformLocation = glGetUniformLocation(s_program, "transform");
	glUniformMatrix4fv(StransformLocation, 1, GL_FALSE, glm::value_ptr(Door));
	qobj = gluNewQuadric();
	gluQuadricDrawStyle(qobj, obj_type);
	objColorLocation = glGetUniformLocation(s_program, "objectColor");
	isCheck = glGetUniformLocation(s_program, "isCheck");
	glUniform1f(isCheck, false);
	glUniform4f(objColorLocation, 1.0f, 1.0f, 0.0f, 1.0);
	glBindVertexArray(VAO[1]);
	glDrawArrays(GL_TRIANGLES, 0, 36);
	// 무대 문(왼쪽)
	glm::mat4 Door1 = glm::mat4(1.0f);
	Door1 = glm::translate(Door1, glm::vec3(0.75f, 0.0f, 0.0f));
	Door1 = glm::rotate(Door1, glm::radians(90.0f), glm::vec3(1.0f, 0.0f, 0.0f));
	Door1 = glm::translate(Door1, glm::vec3(s.x_trans1, 0.f, 0.f));
	Door1 = glm::scale(Door1, glm::vec3(0.75f, 0.0f, 1.5f));
	StransformLocation = glGetUniformLocation(s_program, "transform");
	glUniformMatrix4fv(StransformLocation, 1, GL_FALSE, glm::value_ptr(Door1));
	qobj = gluNewQuadric();
	gluQuadricDrawStyle(qobj, obj_type);
	objColorLocation = glGetUniformLocation(s_program, "objectColor");
	isCheck = glGetUniformLocation(s_program, "isCheck");
	glUniform1f(isCheck, false);
	glUniform4f(objColorLocation, 1.0f, 1.0f, 0.0f, 1.0);
	glBindVertexArray(VAO[1]);
	glDrawArrays(GL_TRIANGLES, 0, 36);

	//장애물
	glm::mat4 Block = glm::mat4(1.0f);
	Block = glm::translate(Block, glm::vec3(block.x_trans,0.f, block.z_trans));
	Block = glm::scale(Block, glm::vec3(0.3f, 0.4f, 0.3f));
	Block = glm::translate(Block, glm::vec3(0.f, -3.0f, 0.f));
	StransformLocation = glGetUniformLocation(s_program, "transform");
	glUniformMatrix4fv(StransformLocation, 1, GL_FALSE, glm::value_ptr(Block));
	qobj = gluNewQuadric();
	gluQuadricDrawStyle(qobj, obj_type);
	objColorLocation = glGetUniformLocation(s_program, "objectColor");
	isCheck = glGetUniformLocation(s_program, "isCheck");
	glUniform1f(isCheck, false);
	glUniform4f(objColorLocation, 1.0f, 1.0f, 1.0f, 1.0);
	glBindVertexArray(VAO[0]);
	glDrawArrays(GL_TRIANGLES, 0, 36);


	//로봇 본체(몸통)
	glm::mat4 Robot = glm::mat4(1.0f);
	Robot = glm::translate(Robot, glm::vec3(robot.x_trans_aoc, robot.y_trans_aoc, robot.z_trans_aoc));
	Robot = glm::rotate(Robot, glm::radians(robot.y_rotate), glm::vec3(0.f, 1.0f, 0.f));
	Robot = glm::translate(Robot, glm::vec3(0.f, 0.5f - 0.5f * 0.5f, 0.f));
	Robot = glm::scale(Robot, glm::vec3(0.2f, 0.5f, 0.2f));
	StransformLocation = glGetUniformLocation(s_program, "transform");
	glUniformMatrix4fv(StransformLocation, 1, GL_FALSE, glm::value_ptr(Robot));
	qobj = gluNewQuadric();
	gluQuadricDrawStyle(qobj, obj_type);
	objColorLocation = glGetUniformLocation(s_program, "objectColor");
	isCheck = glGetUniformLocation(s_program, "isCheck");
	glUniform1f(isCheck, false);
	glUniform4f(objColorLocation, 0.3f, 1.0f, 0.5f, 1.0);
	glBindVertexArray(VAO[0]);
	glDrawArrays(GL_TRIANGLES, 0, 36);

	//로봇 다리
	Robot = glm::mat4(1.0f);




	
	glutSwapBuffers();
}
void Reshape(int w, int h) {

	g_window_w = w;
	g_window_h = h;
	glViewport(0, 0, w, h);

}

GLvoid KeyBoard(unsigned char key, int x, int y) {
	switch (key)
	{
	case 'o':
		h_f.door_open = !h_f.door_open;
		break;
	case 'O':
		h_f.door_close = !h_f.door_close;  // 이건 나중에 한번 해 보기.
		break;
	case 'w':
		s.z_trans_aoc += 0.1f;
		break;
	case 'a':
		s.x_trans_aoc += 0.1f;
		break;
	case 's':
		s.z_trans_aoc -= 0.1f;
		break;
	case 'd':
		s.x_trans_aoc -= 0.1f;
		break;
	case 'j':
		if (s.y_trans_aoc < 0.2f)
			s.y_trans_aoc += 0.25f;
		else if (s.y_trans_aoc > 0.2f)
			s.y_trans_aoc -= 0.25f;
		break;
	case 'i':
		memcpy(&s, &temp, sizeof(s));
		memcpy(&camera, &temp, sizeof(camera));
		memcpy(&h_f, &temp_f, sizeof(h_f));
		break;
	case 'z':
		h_f.z_is_trans = !h_f.z_is_trans;
		break;
	case 'Z':
		h_f.z_is_reverse_trans = !h_f.z_is_reverse_trans;
		break;
	case 'x':
		h_f.x_is_trans = !h_f.x_is_trans;
		break;
	case 'X':
		h_f.x_is_reverse_trans = !h_f.x_is_reverse_trans;
		break;
	case 'y':
		h_f.y_is_rotate = !h_f.y_is_rotate;
		break;
	case 'Y':
		h_f.y_is_reverse_rotate = !h_f.y_is_reverse_rotate;
		break;
	case 'q':
		exit(0);
		break;
	}
	glutPostRedisplay();
}

GLvoid Timer(int value)
{
	if (h_f.start_timer) {

		if (h_f.door_open && s.x_trans > -1.5) {
			s.x_trans -= 0.01f;
		}
		if (h_f.door_open && s.x_trans1 < 1.5) {
			s.x_trans1 += 0.01f;
		}

			

		if (h_f.z_is_trans)
			camera.z_trans += 0.01;
		if (h_f.z_is_reverse_trans)
			camera.z_trans -= 0.01;

		if (h_f.x_is_trans)
			camera.x_trans += 0.01;
		if (h_f.x_is_reverse_trans)
			camera.x_trans -= 0.01;

		if (h_f.y_is_rotate)
			camera.y_rotate_aoc += 0.1;
		if (h_f.y_is_reverse_rotate)
			camera.y_rotate_aoc -= 0.1;

	}

	glutPostRedisplay();
	glutTimerFunc(5, Timer, 1);
}

GLvoid Motion(int x, int y)
{
	glutPostRedisplay();
}

GLvoid Mouse(int button, int state, int x, int y)
{
	glutPostRedisplay();
}

void main(int argc, char** argv) {
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
	glutInitWindowPosition(0, 0);
	glutInitWindowSize(width, height);
	glutCreateWindow("C.G_NO.20");

	glewExperimental = GL_TRUE;
	if (glewInit() != GLEW_OK)
	{
		cerr << "NOT INIT" << endl;
	}
	else
		cout << "INIT" << endl;
	cout << "o/O 무대 열기/닫기(닫기는 구현중)" << endl;
	cout << "w/a/s/d 로봇이 걸으면서 움직임" << endl;
	cout << "+/- 걷는 속도가 빨라지거나 느려짐" << endl;
	cout << "j 로봇이 제자리에서 점프" << endl;  // 이거 되간 하지만 좀 이상..;;;;
	cout << "i 모든 움직임이 초기화(초기 상태로ㄱㄱ)" << endl;
	cout << "z/Z 카메라가 z축으로 양/음 방향으로 이동" << endl;
	cout << "x/X 카메라가 x축으로 양/음 방향으로 이동" << endl;
	cout << "y/Y 화면의 중심의 y축에 대하여 카메라가 회전(중점이 중심으로 공전)" << endl;
	cout << "q 프로그램 종료" << endl;

	InitShader();
	InitBuffer();
	glEnable(GL_DEPTH_TEST);
	glFrontFace(GL_CW);
	glutDisplayFunc(drawScene);
	glutKeyboardFunc(KeyBoard);
	glutMouseFunc(Mouse);
	glutMotionFunc(Motion);
	glutReshapeFunc(Reshape);
	glutTimerFunc(5, Timer, 1);
	glutMainLoop();
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}
